#!/usr/bin/env python3
"""
Simple HTTP server that listens for requests from dev containers.
- Opens URLs in the default browser on the host
- Opens files/directories in Cursor (attached to the dev container)
- Clipboard forwarding (pbcopy/pbpaste) between container and host

Usage: url-listener [--port PORT]
Default port: 7077
"""

import argparse
import json
import signal
import subprocess
import sys
import threading
import urllib.parse
from http.server import HTTPServer, BaseHTTPRequestHandler
from pathlib import Path

CURSOR_CONTAINER_CONFIG_DIR = Path.home() / "Library/Application Support/Cursor/User/globalStorage/anysphere.remote-containers/nameConfigs"


def write_container_config(container_name: str, extensions: list[str], remote_user: str | None = None) -> None:
    """Write extensions and settings to Cursor's attached container config file."""
    CURSOR_CONTAINER_CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    config_path = CURSOR_CONTAINER_CONFIG_DIR / f"{container_name}.json"
    config = {
        "extensions": extensions,
        "settings": {
            "python.defaultInterpreterPath": "/opt/python/bin/python3",
        },
    }
    if remote_user:
        config["remoteUser"] = remote_user
    config_path.write_text(json.dumps(config, indent=2) + "\n")


class URLHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed = urllib.parse.urlparse(self.path)
        params = urllib.parse.parse_qs(parsed.query)

        if parsed.path == "/open" and "url" in params:
            url = params["url"][0]
            subprocess.run(["open", url], check=False)
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"OK")
        elif parsed.path == "/cursor" and "container" in params and "path" in params:
            container_name = params["container"][0]
            container_path = params["path"][0]
            is_file = params.get("file", ["0"])[0] == "1"
            extensions_param = params.get("extensions", [""])[0]
            remote_user = params.get("user", [None])[0]
            extensions = [e.strip() for e in extensions_param.split(",") if e.strip()] if extensions_param else []
            write_container_config(container_name, extensions, remote_user)
            config = json.dumps({"containerName": f"/{container_name}"})
            hex_config = config.encode().hex()
            uri = f"vscode-remote://attached-container+{hex_config}{container_path}"
            if is_file:
                subprocess.run(["cursor", "--new-window", "--file-uri", uri], check=False)
            else:
                subprocess.run(["cursor", "--new-window", "--folder-uri", uri], check=False)
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"OK")
        elif parsed.path == "/paste":
            result = subprocess.run(["pbpaste"], capture_output=True)
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(result.stdout)
        elif parsed.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"OK")
        else:
            self.send_response(404)
            self.end_headers()

    def do_POST(self):
        parsed = urllib.parse.urlparse(self.path)
        if parsed.path == "/copy":
            content_length = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_length)
            subprocess.run(["pbcopy"], input=body, check=False)
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"OK")
        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        pass


def main():
    parser = argparse.ArgumentParser(description="URL listener for dev containers")
    parser.add_argument("--port", type=int, default=7077, help="Port to listen on")
    args = parser.parse_args()

    server = HTTPServer(("0.0.0.0", args.port), URLHandler)
    signal.signal(signal.SIGTERM, lambda *_: threading.Thread(target=server.shutdown).start())
    print(f"URL listener started on port {args.port}", file=sys.stderr)
    try:
        server.serve_forever(poll_interval=0.1)
    except KeyboardInterrupt:
        pass
    server.server_close()


if __name__ == "__main__":
    main()
