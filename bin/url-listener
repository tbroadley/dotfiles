#!/usr/bin/env python3
"""
Simple HTTP server that listens for requests from dev containers.
- Opens URLs in the default browser on the host
- Opens files/directories in Cursor (attached to the dev container)
- Clipboard forwarding (pbcopy/pbpaste) between container and host

Usage: url-listener [--port PORT]
Default port: 7077
"""

import argparse
import json
import signal
import subprocess
import sys
import threading
import urllib.parse
from http.server import HTTPServer, BaseHTTPRequestHandler
from pathlib import Path

CURSOR_CONTAINER_CONFIG_DIR = Path.home() / "Library/Application Support/Cursor/User/globalStorage/anysphere.remote-containers/nameConfigs"


def write_container_config(
    container_name: str,
    extensions: list[str],
    settings: dict | None = None,
    remote_user: str | None = None,
) -> None:
    """Write extensions and settings to Cursor's attached container config file."""
    CURSOR_CONTAINER_CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    config_path = CURSOR_CONTAINER_CONFIG_DIR / f"{container_name}.json"
    # Use provided settings from devcontainer.json, default to empty dict
    config_settings = settings if settings else {}
    # Ensure python.defaultInterpreterPath is set if not specified
    config_settings.setdefault("python.defaultInterpreterPath", "/opt/python/bin/python3")
    config = {
        "extensions": extensions,
        "settings": config_settings,
    }
    if remote_user:
        config["remoteUser"] = remote_user
    config_path.write_text(json.dumps(config, indent=2) + "\n")


class URLHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed = urllib.parse.urlparse(self.path)
        params = urllib.parse.parse_qs(parsed.query)

        if parsed.path == "/open" and "url" in params:
            url = params["url"][0]
            subprocess.run(["open", url], check=False)
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"OK")
        elif parsed.path == "/cursor" and "container" in params and "path" in params:
            container_name = params["container"][0]
            paths = params["path"]
            is_file = params.get("file", ["0"])[0] == "1"
            extensions_param = params.get("extensions", [""])[0]
            settings_param = params.get("settings", ["{}"])[0]
            remote_user = params.get("user", [None])[0]
            extensions = [e.strip() for e in extensions_param.split(",") if e.strip()] if extensions_param else []
            try:
                settings = json.loads(settings_param) if settings_param else {}
            except json.JSONDecodeError:
                settings = {}
            write_container_config(container_name, extensions, settings, remote_user)
            config = json.dumps({"containerName": f"/{container_name}"})
            hex_config = config.encode().hex()
            if is_file:
                cmd = ["cursor", "--new-window"]
                for p in paths:
                    cmd.extend(["--file-uri", f"vscode-remote://attached-container+{hex_config}{p}"])
                subprocess.run(cmd, check=False)
            else:
                uri = f"vscode-remote://attached-container+{hex_config}{paths[0]}"
                subprocess.run(["cursor", "--new-window", "--folder-uri", uri], check=False)
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"OK")
        elif parsed.path == "/wispr-dictionary":
            phrase = params.get("phrase", [""])[0]
            replacement = params.get("replacement", [None])[0]
            is_snippet = params.get("snippet", ["0"])[0] == "1"
            no_refresh = params.get("no_refresh", ["0"])[0] == "1"
            if not phrase:
                self.send_response(400)
                self.send_header("Content-Type", "text/plain")
                self.end_headers()
                self.wfile.write(b"Missing phrase parameter")
                return
            cmd = [str(Path.home() / "dotfiles/bin/wispr-add-dictionary"), phrase]
            if replacement:
                cmd.append(replacement)
            if is_snippet:
                cmd.insert(1, "--snippet")
            if no_refresh:
                cmd.insert(1, "--no-refresh")
            result = subprocess.run(cmd, capture_output=True, text=True)
            self.send_response(200 if result.returncode == 0 else 500)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write((result.stdout + result.stderr).encode())
        elif parsed.path == "/paste":
            result = subprocess.run(["pbpaste"], capture_output=True)
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(result.stdout)
        elif parsed.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"OK")
        else:
            self.send_response(404)
            self.end_headers()

    def do_POST(self):
        parsed = urllib.parse.urlparse(self.path)
        if parsed.path == "/copy":
            content_length = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_length)
            subprocess.run(["pbcopy"], input=body, check=False)
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"OK")
        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        pass


def main():
    parser = argparse.ArgumentParser(description="URL listener for dev containers")
    parser.add_argument("--port", type=int, default=7077, help="Port to listen on")
    args = parser.parse_args()

    server = HTTPServer(("0.0.0.0", args.port), URLHandler)
    signal.signal(signal.SIGTERM, lambda *_: threading.Thread(target=server.shutdown).start())
    print(f"URL listener started on port {args.port}", file=sys.stderr)
    try:
        server.serve_forever(poll_interval=0.1)
    except KeyboardInterrupt:
        pass
    server.server_close()


if __name__ == "__main__":
    main()
