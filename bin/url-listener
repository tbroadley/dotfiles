#!/usr/bin/env python3
"""
Simple HTTP server that listens for requests from dev containers.
- Opens URLs in the default browser on the host
- Opens files/directories in Cursor (attached to the dev container)
- Clipboard forwarding (pbcopy/pbpaste) between container and host

Usage: url-listener [--port PORT]
Default port: 7077
"""

import argparse
import signal
import subprocess
import sys
import urllib.parse
from http.server import HTTPServer, BaseHTTPRequestHandler


class URLHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed = urllib.parse.urlparse(self.path)
        params = urllib.parse.parse_qs(parsed.query)

        if parsed.path == "/open" and "url" in params:
            url = params["url"][0]
            subprocess.run(["open", url], check=False)
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"OK")
        elif parsed.path == "/cursor" and "container" in params and "path" in params:
            container_name = params["container"][0]
            container_path = params["path"][0]
            is_file = params.get("file", ["0"])[0] == "1"
            extensions = params.get("extensions", [""])[0]
            import json
            config = json.dumps({"containerName": f"/{container_name}"})
            hex_config = config.encode().hex()
            if is_file:
                uri = f"vscode-remote://attached-container+{hex_config}{container_path}"
                subprocess.run(["cursor", "--file-uri", uri], check=False)
            else:
                uri = f"cursor://vscode-remote/attached-container+{hex_config}{container_path}"
                subprocess.run(["open", uri], check=False)
            if extensions:
                for ext in extensions.split(","):
                    ext = ext.strip()
                    if ext:
                        subprocess.run(["cursor", "--install-extension", ext], check=False)
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"OK")
        elif parsed.path == "/paste":
            result = subprocess.run(["pbpaste"], capture_output=True)
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(result.stdout)
        elif parsed.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"OK")
        else:
            self.send_response(404)
            self.end_headers()

    def do_POST(self):
        parsed = urllib.parse.urlparse(self.path)
        if parsed.path == "/copy":
            content_length = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_length)
            subprocess.run(["pbcopy"], input=body, check=False)
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"OK")
        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        pass


def main():
    parser = argparse.ArgumentParser(description="URL listener for dev containers")
    parser.add_argument("--port", type=int, default=7077, help="Port to listen on")
    args = parser.parse_args()

    server = HTTPServer(("0.0.0.0", args.port), URLHandler)
    signal.signal(signal.SIGTERM, lambda *_: server.shutdown())
    print(f"URL listener started on port {args.port}", file=sys.stderr)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        pass
    server.server_close()


if __name__ == "__main__":
    main()
