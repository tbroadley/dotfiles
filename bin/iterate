#!/bin/bash
set -euo pipefail

for cmd in node claude git; do
    if ! command -v "$cmd" &>/dev/null; then
        echo "Error: '$cmd' is required but not found in PATH" >&2
        exit 1
    fi
done

if ! git rev-parse --git-dir &>/dev/null; then
    echo "Error: not a git repository" >&2
    exit 1
fi

MAX_ITERATIONS="${ITERATE_MAX:-10}"
CUMULATIVE_LOG=$(mktemp)
REVIEW_JSON_FILE=$(mktemp)
TEMP_FILES=("$CUMULATIVE_LOG" "$REVIEW_JSON_FILE")
trap 'rm -f "${TEMP_FILES[@]}"' EXIT

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >&2
}

get_base_branch() {
    # Try local ref first (no network needed), fall back to remote query
    git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|refs/remotes/origin/||' \
        || git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d: -f2 | xargs \
        || echo "main"
}

get_diff() {
    local base_branch current_branch
    base_branch=$(get_base_branch)
    if [[ -z "$base_branch" ]]; then
        log "ERROR: Could not determine base branch"
        return 1
    fi
    current_branch=$(git branch --show-current 2>/dev/null || echo "")
    git fetch origin "$base_branch" --quiet 2>/dev/null || true

    if [[ "$current_branch" == "$base_branch" ]]; then
        # On the base branch: review staged + unstaged changes against origin
        git diff "origin/${base_branch}"
    else
        # On feature branch: review branch diff against base
        git diff "origin/${base_branch}...HEAD"
    fi
}

get_claude_md() {
    if [[ -f "CLAUDE.md" ]]; then
        cat CLAUDE.md
    fi
}

REVIEW_SCHEMA='{
  "type": "object",
  "properties": {
    "verdict": {
      "type": "string",
      "enum": ["continue", "done"]
    },
    "findings": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "severity": {
            "type": "string",
            "enum": ["error", "warning", "nit"]
          },
          "file": { "type": "string" },
          "description": { "type": "string" }
        },
        "required": ["severity", "file", "description"]
      }
    },
    "summary": { "type": "string" },
    "justification_for_stopping": { "type": "string" },
    "oscillation_detected": { "type": "boolean" }
  },
  "required": ["verdict", "findings", "summary", "oscillation_detected"]
}'

# Runs review agent, writes structured JSON to REVIEW_JSON_FILE
run_review() {
    local iteration=$1
    local diff cumulative claude_md prompt_file

    diff=$(get_diff)
    cumulative=$(cat "$CUMULATIVE_LOG")
    claude_md=$(get_claude_md)

    if [[ -z "$diff" ]]; then
        log "No changes to review"
        echo '{"verdict":"done","findings":[],"summary":"No changes to review","oscillation_detected":false,"justification_for_stopping":"No changes found"}' > "$REVIEW_JSON_FILE"
        return
    fi

    prompt_file=$(mktemp)
    TEMP_FILES+=("$prompt_file")
    cat > "$prompt_file" <<PROMPT
You are a code reviewer. Review the following diff for issues: bugs, style violations, missing tests, code smells, and anything that should be fixed before merging.

You have access to tools — use them to read files, run linters, or check context if the diff alone is insufficient.

IMPORTANT anti-oscillation rules:
- Read the cumulative summary carefully. If a previous iteration already fixed an issue, do NOT re-report it or report the inverse change as a new issue.
- If you see the same issue being fixed and then re-introduced across iterations, set oscillation_detected to true.
- Bias toward 'done' — only return 'continue' if there are genuinely actionable findings that haven't been addressed yet.
- Nits alone are NOT sufficient to continue. Only errors and warnings justify continuing.

$(if [[ -n "$claude_md" ]]; then printf '## Project coding standards (CLAUDE.md)\n%s\n' "$claude_md"; fi)

$(if [[ -n "$cumulative" ]]; then printf '## Cumulative summary from previous iterations\n%s\n' "$cumulative"; fi)

## Diff to review (iteration $iteration)
\`\`\`diff
$diff
\`\`\`

Return your structured review.
PROMPT

    local claude_output_file
    claude_output_file=$(mktemp)
    TEMP_FILES+=("$claude_output_file" "$prompt_file.stderr")
    claude --print --output-format json --model sonnet --no-session-persistence --json-schema "$REVIEW_SCHEMA" < "$prompt_file" > "$claude_output_file" 2>"$prompt_file.stderr"
    if [[ -s "$prompt_file.stderr" ]]; then
        log "Review agent stderr: $(cat "$prompt_file.stderr")"
    fi
    node -pe "JSON.stringify(JSON.parse(require('fs').readFileSync('$claude_output_file','utf8')).structured_output)" \
        > "$REVIEW_JSON_FILE"
    rm -f "$prompt_file" "$claude_output_file" "$prompt_file.stderr"
}

run_fix() {
    local iteration=$1
    local cumulative result_file prompt_file

    cumulative=$(cat "$CUMULATIVE_LOG")
    result_file=$(mktemp)
    prompt_file=$(mktemp)
    TEMP_FILES+=("$result_file" "$prompt_file")

    local findings_text
    findings_text=$(node -pe "
        const r = JSON.parse(require('fs').readFileSync('$REVIEW_JSON_FILE', 'utf8'));
        r.findings.map((f,i) => '  ' + (i+1) + '. [' + f.severity + '] ' + f.file + ': ' + f.description).join('\n')
    ")

    cat > "$prompt_file" <<PROMPT
You are an autonomous code fixer. Address the following review findings, validate your changes, commit, and push.

## Review Findings (iteration $iteration)
$findings_text

$(if [[ -n "$cumulative" ]]; then printf '## Cumulative summary from previous iterations (avoid re-introducing old issues)\n%s\n' "$cumulative"; fi)

## Instructions
1. Fix each finding listed above
2. Run the project's linter and type checker to validate (check CLAUDE.md for commands)
3. Run the formatter
4. Stage, commit with a descriptive message ending with:
   Co-Authored-By: Claude <noreply@anthropic.com>
5. Push to remote

Work autonomously. Do not ask for confirmation. If a finding is a false positive, skip it and note why.
PROMPT

    claude --print --verbose --output-format stream-json --model opus --no-session-persistence < "$prompt_file" 2>&1 | while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        TYPE=$(node -pe "try{JSON.parse(process.argv[1]).type}catch{''}" "$line" 2>/dev/null || echo "")
        case "$TYPE" in
            assistant)
                node -pe "
                    const content = JSON.parse(process.argv[1]).message?.content || [];
                    content.filter(c => c.type === 'tool_use').forEach(c => {
                        console.error('[Tool] ' + c.name + ': ' + JSON.stringify(c.input).substring(0, 200));
                    });
                    content.filter(c => c.type === 'text').map(c => c.text).join('') || ''" "$line" 2>/dev/null || true
                ;;
            user)
                node -pe "
                    const content = JSON.parse(process.argv[1]).message?.content || [];
                    content.filter(c => c.type === 'tool_result').forEach(c => {
                        const result = typeof c.content === 'string' ? c.content : JSON.stringify(c.content);
                        const truncated = result.length > 300 ? result.substring(0, 300) + '...' : result;
                        console.error('[Tool Result] ' + truncated);
                    });
                    ''" "$line" 2>/dev/null || true
                ;;
            result)
                MSG=$(node -pe "JSON.parse(process.argv[1]).result||''" "$line" 2>/dev/null || echo "")
                if [[ -n "$MSG" ]]; then
                    echo "$MSG" > "$result_file"
                fi
                ;;
        esac
    done || log "Fix agent exited with error"

    rm -f "$prompt_file"
    if [[ -f "$result_file" ]]; then
        cat "$result_file"
        rm -f "$result_file"
    fi
}

append_to_cumulative() {
    local iteration=$1
    local fix_result=${2:-""}

    local summary
    summary=$(node -pe "
        const r = JSON.parse(require('fs').readFileSync('$REVIEW_JSON_FILE', 'utf8'));
        const counts = {error: 0, warning: 0, nit: 0};
        r.findings.forEach(f => counts[f.severity]++);
        'Iteration ' + $iteration + ': ' + counts.error + ' errors, ' + counts.warning + ' warnings, ' + counts.nit + ' nits. ' + r.summary
    ")

    {
        echo "---"
        echo "$summary"
        if [[ -n "$fix_result" ]]; then
            echo "Fix agent result: ${fix_result:0:500}"
        fi
    } >> "$CUMULATIVE_LOG"
}

run_review_loop() {
    log "Starting autonomous review loop (max $MAX_ITERATIONS iterations)"

    local i
    for (( i=1; i<=MAX_ITERATIONS; i++ )); do
        log "=== Iteration $i/$MAX_ITERATIONS ==="

        log "Running review agent..."
        run_review "$i"

        local review_json
        review_json=$(cat "$REVIEW_JSON_FILE")

        if [[ -z "$review_json" || "$review_json" == "null" ]]; then
            log "Review agent returned empty response, stopping"
            break
        fi

        local verdict oscillation findings_count summary
        verdict=$(node -pe "JSON.parse(require('fs').readFileSync('$REVIEW_JSON_FILE','utf8')).verdict" 2>/dev/null || echo "done")
        oscillation=$(node -pe "JSON.parse(require('fs').readFileSync('$REVIEW_JSON_FILE','utf8')).oscillation_detected" 2>/dev/null || echo "false")
        findings_count=$(node -pe "JSON.parse(require('fs').readFileSync('$REVIEW_JSON_FILE','utf8')).findings.length" 2>/dev/null || echo "0")
        summary=$(node -pe "JSON.parse(require('fs').readFileSync('$REVIEW_JSON_FILE','utf8')).summary" 2>/dev/null || echo "")

        log "Review: $findings_count findings — $summary"

        if [[ "$oscillation" == "true" ]]; then
            log "Oscillation detected, stopping"
            append_to_cumulative "$i"
            break
        fi

        if [[ "$verdict" == "done" ]]; then
            local justification
            justification=$(node -pe "JSON.parse(require('fs').readFileSync('$REVIEW_JSON_FILE','utf8')).justification_for_stopping||''" 2>/dev/null || echo "")
            log "Review says done: $justification"
            append_to_cumulative "$i"
            break
        fi

        log "Running fix agent..."
        local fix_result
        fix_result=$(run_fix "$i")

        append_to_cumulative "$i" "$fix_result"
        log "Iteration $i complete"
    done

    if (( i > MAX_ITERATIONS )); then
        log "Reached max iterations ($MAX_ITERATIONS), stopping"
    fi

    log "Review loop finished"
    echo "" >&2
    log "Cumulative log:"
    cat "$CUMULATIVE_LOG" >&2
}

usage() {
    cat >&2 <<EOF
Usage: iterate [plan "task description" | review]

Modes:
  iterate plan "Add feature X"   Interactive planning session, then autonomous review loop
  iterate review                  Autonomous review loop only (default)
  iterate                         Same as 'iterate review'

Environment:
  ITERATE_MAX   Max review iterations (default: 10)
EOF
    exit 1
}

main() {
    local mode="review"
    local task_description=""

    if [[ $# -ge 1 ]]; then
        case "$1" in
            plan)
                mode="plan"
                shift
                if [[ $# -ge 1 ]]; then
                    task_description="$*"
                else
                    echo "Error: 'plan' mode requires a task description" >&2
                    usage
                fi
                ;;
            review)
                mode="review"
                ;;
            -h|--help|help)
                usage
                ;;
            *)
                echo "Unknown command: $1" >&2
                usage
                ;;
        esac
    fi

    if [[ "$mode" == "plan" ]]; then
        log "Starting interactive planning session..."
        log "Task: $task_description"
        log "Exit the session (Ctrl+C or /exit) to start the autonomous review loop"
        echo ""

        claude "$task_description" || true

        echo ""
        log "Planning session ended, starting review loop..."
    fi

    run_review_loop
}

main "$@"
