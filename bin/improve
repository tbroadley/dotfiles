#!/bin/bash
set -euo pipefail

SCRIPT_PATH="$0"
POLL_INTERVAL=60
STATE_DIR="$HOME/.claude/state"
REPO_DIR="$(pwd)"
REPO_HASH=$(echo -n "$REPO_DIR" | md5sum 2>/dev/null | cut -c1-8 || echo -n "$REPO_DIR" | md5 | cut -c1-8)
SEEN_TASKS_FILE="$STATE_DIR/improve-seen-tasks-$REPO_HASH"

mkdir -p "$STATE_DIR"
touch "$SEEN_TASKS_FILE"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

flush_seen_tasks() {
    > "$SEEN_TASKS_FILE"
    log "Flushed seen tasks list - all tasks will be reconsidered on next poll"
}

is_devcontainer() {
    [[ -f /.dockerenv ]] || [[ -n "${REMOTE_CONTAINERS:-}" ]] || [[ -n "${CODESPACES:-}" ]]
}

update_and_restart() {
    if is_devcontainer; then
        log "Inside dev container, updating dotfiles..."
        if git -C ~/dotfiles pull 2>/dev/null; then
            log "Pulled latest dotfiles"
            if ~/dotfiles/install.sh >/dev/null 2>&1; then
                log "Ran install.sh successfully, restarting improve..."
                exec "$SCRIPT_PATH"
            else
                log "install.sh failed, continuing without restart"
            fi
        else
            log "git pull failed, continuing without restart"
        fi
    fi
}

log "Starting improve for: $REPO_DIR"
log "Seen tasks file: $SEEN_TASKS_FILE"
log "Poll interval: ${POLL_INTERVAL}s"
log "Press 'f' to flush seen tasks list"

while true; do
    SEEN_TASKS=$(cat "$SEEN_TASKS_FILE")

    log "Checking for unseen tasks..."

    NEW_TASKS=$(curl -s "https://api.todoist.com/rest/v2/tasks" \
        -H "Authorization: Bearer $TODOIST_TOKEN" | \
        node -e "
const seenTasks = new Set(\`$SEEN_TASKS\`.split('\n').filter(Boolean));

let data = '';
process.stdin.on('data', chunk => data += chunk);
process.stdin.on('end', () => {
    try {
        const tasks = JSON.parse(data);
        const newTasks = tasks.filter(t => !seenTasks.has(t.id)).map(t => ({
            id: t.id,
            content: t.content,
            description: t.description || '',
            project_id: t.project_id || ''
        }));
        if (newTasks.length > 0) {
            console.log(JSON.stringify(newTasks));
        }
    } catch (e) {}
});
" 2>/dev/null || echo "")

    if [[ -n "$NEW_TASKS" && "$NEW_TASKS" != "[]" ]]; then
        TASK_COUNT=$(echo "$NEW_TASKS" | node -e "let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>console.log(JSON.parse(d).length));")
        log "Found $TASK_COUNT new task(s), invoking Claude Code..."

        cd "$REPO_DIR"

        claude --print --verbose --output-format stream-json "You are watching Todoist for tasks to implement in this repo.

Here are newly created Todoist tasks (JSON format):
$NEW_TASKS

For each task:
1. Analyze if it's relevant to this repo ($(basename "$REPO_DIR"))
2. If relevant: implement the task, commit with message referencing the task ID, push to remote
3. After successful push, mark the task complete using:
   curl -X POST \"https://api.todoist.com/rest/v2/tasks/{task_id}/close\" -H \"Authorization: Bearer \$TODOIST_TOKEN\"
4. If not relevant: skip silently

Work autonomously. Do not ask for confirmation." 2>&1 | while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            TYPE=$(node -pe "try{JSON.parse(process.argv[1]).type}catch{''}" "$line" 2>/dev/null || echo "")
            case "$TYPE" in
                assistant)
                    # Print tool calls
                    node -pe "
                        const content = JSON.parse(process.argv[1]).message?.content || [];
                        content.filter(c => c.type === 'tool_use').forEach(c => {
                            console.log('[Tool] ' + c.name + ': ' + JSON.stringify(c.input));
                        });
                        ''" "$line" 2>/dev/null || true
                    # Print text content
                    node -pe "JSON.parse(process.argv[1]).message?.content?.filter(c=>c.type==='text').map(c=>c.text).join('')||''" "$line" 2>/dev/null || true
                    ;;
                user)
                    # Print tool results
                    node -pe "
                        const content = JSON.parse(process.argv[1]).message?.content || [];
                        content.filter(c => c.type === 'tool_result').forEach(c => {
                            const result = typeof c.content === 'string' ? c.content : JSON.stringify(c.content);
                            const truncated = result.length > 500 ? result.substring(0, 500) + '...' : result;
                            console.log('[Tool Result] ' + truncated);
                        });
                        // Print user text messages
                        content.filter(c => c.type === 'text').forEach(c => {
                            console.log('[User] ' + c.text);
                        });
                        ''" "$line" 2>/dev/null || true
                    ;;
                result)
                    MSG=$(node -pe "JSON.parse(process.argv[1]).result||''" "$line" 2>/dev/null || echo "")
                    [[ -n "$MSG" ]] && log "Result: $MSG"
                    ;;
            esac
        done || log "Claude Code exited with error"

        echo "$NEW_TASKS" | node -pe "JSON.parse(require('fs').readFileSync(0,'utf8')).map(t=>t.id).join('\n')" >> "$SEEN_TASKS_FILE"

    else
        log "No new tasks found"
    fi

    # Always update dotfiles and restart every poll cycle (60s)
    update_and_restart

    log "Sleeping for ${POLL_INTERVAL}s... (press 'f' to flush seen tasks)"

    # Use read with timeout to allow keyboard input during sleep
    SLEEP_REMAINING=$POLL_INTERVAL
    while (( SLEEP_REMAINING > 0 )); do
        if read -t 1 -n 1 key 2>/dev/null; then
            case "$key" in
                f|F)
                    flush_seen_tasks
                    ;;
            esac
        fi
        (( SLEEP_REMAINING-- )) || true
    done
done
